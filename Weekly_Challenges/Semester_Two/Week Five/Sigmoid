clear all;
load("mnist.mat");

%Taken from Week One
XTestReshape = reshape(XTest,28,28,10000);
XTestReshapeForDiv = reshape(XTestReshape, [], 10000);
XTestTrans = transpose(XTestReshapeForDiv);
YTestTrans = transpose(YTest);
%Assuming W to be the coefficients from Ax = B
WTest = mrdivide(XTestReshapeForDiv,YTestTrans);

WTestSize = size(WTest);
WTestLength = WTestSize(1);
randval = randi(WTestLength);

%Testing what happens if w_0 is a random element
w = WTest(randval,1);
%w_0 has a value of zero so has little to no effect on the rest
WTestTrans = transpose(WTest);
%Now we take X to be A, z to be B, W to be x, and w is a weight
z = (WTestTrans * XTestReshapeForDiv) + w;
YTestHat = sigfunc(z);
YTestHatTrans = transpose(YTestHat);
wRidge = ridge(YTest,YTestHatTrans,5);
%wLasso = lasso(YTestHat,YTest);
lossfunc = crossentropy(YTest,YTestHat);
deltaW = gradDescent(YTestTrans,XTestTrans,WTest,w,5);

%These are steps one and two
function sigmoid = sigfunc(z)
    den = 1 - exp(-z);
    %Made this mldivide so it could work
    %sigmoid = mldivide(1,den);
    %Wondered what change elementwise would make
    sigmoid = 1 ./ den;
end

function CELoss = crossentropy(Y,YHat)
    bracOne = 1 - Y;
    bracTwo = 1 - YHat;
    logOne = Y * log(YHat);
    logTwo = bracOne * log(bracTwo);
    CELoss = -(logOne + logTwo);
end

function deltaW = gradDescent(Y,x,W,b,a)
% dL/dW derived using a derivative calculator
    eCoefPos = (x * W) + b;
    eCoefNeg = -(x * W) - b;
    ePos = exp(eCoefPos);
    eNeg = exp(eCoefNeg);
    Ymin = Y - 1;
    den = (Y * x * ePos) * ((Ymin * ePos) + Y);
    num = (ePos + 1) * (((Ymin * ePos) + Y - 1) * log(1 - (1/eNeg) + 1) - ePos);
    deriv = den / num;
    deltaW = W + (a * deriv);
end











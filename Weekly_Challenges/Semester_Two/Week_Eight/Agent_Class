#include <iostream>
#include "OneDMat.hpp"
#include "Functions.hpp"
using namespace std;
#ifndef AGENTHEADERDEF
#define AGENTHEADERDEF

class agent {
public:
	int designation;
	int size;
	double* pos;
	double* vel;
	double* p_loc;
	double* p_glob;
	agent(int des, int iter, double pos_init, double vel_init);
	double velOne(double currVel, double currPos, double locPos, double g_inc);
	double* positionArr(double g_inc, double* f);
	double findPLoc(int iter, double* f);
	double velTwo(double currVel, double currPos, double locPos, double globPos);
	double velThree(double currVel, double currPos, double locPos, double globPos, double cOne, double cTwo, double w);
};

agent::agent(int des, int iter, double pos_init, double vel_init) {
	designation = des;
	size = iter;
	pos = new double[size];
	vel = new double[size];
	pos[0] = pos_init;
	vel[0] = vel_init;
	p_loc = new double[size];
	p_glob = new double[size];
	p_loc[0] = 0;
	p_glob[0] = 0;
}

double agent::velOne(double currVel, double currPos, double locPos, double g_inc) {
	double velVal;
	double rand = randDoubOne();
	//This is the original velocity adjustment
	//double direction = rand * g_inc;
	//This one is accelerated by distance from the minima
	double direction = rand * g_inc * abs(locPos - currPos);

	if (currPos > locPos) {
		velVal = currVel - direction;
		return velVal;
	}
	else if (currPos < locPos) {
		velVal = currVel + direction;
		return velVal;
	}
	else {
		velVal = currVel;
		return velVal;
	}
}

double* agent::positionArr(double g_inc, double* f) {
	int i, j;
	double cOne, cTwo, w;
	cOne = randDoubOne();
	cTwo = randDoubOne();
	w = randDoubOne();
	for (i = 1; i < size; i++) {
		j = i - 1;
		pos[i] = pos[j] + vel[j];
		//Working on the loss function for p_glob. Set it to 100 for Cornfield
		p_loc[i] = findPLoc(i,f);
		p_glob[i] = 100;
		//vel[i] = velOne(vel[j], pos[i], p_loc[i], g_inc);
		//vel[i] = velTwo(vel[j], pos[i], p_loc[i], p_glob[i]);
		vel[i] = velThree(vel[j], pos[i], p_loc[i], p_glob[i], cOne, cTwo, w);
	}
	return pos;
}

double agent::findPLoc(int iter, double* f) {
	int i, j;
	double lossIter, lossPast, diffIter, diffPast, out = pos[iter];

	for (i = 1; i < iter; i++) {
		j = i - 1;
		lossIter = lossfunc(i, pos, f);
		lossPast = lossfunc(j, pos, f);
		diffIter = 0 + abs(lossIter);
		diffPast = 0 + abs(lossPast);

		if (diffIter < diffPast) {
			out = pos[i];
		}
		else if (diffIter > diffPast) {
			out = p_loc[j];
		}
		else if (diffIter = diffPast) {
			out = pos[i];
		}
		else {
			out = pos[i];
		}
	}
	return out;
	
}

double agent::velTwo(double currVel, double currPos, double locPos, double globPos) {
	double velVal;
	double rand = randDoubOne();
	double direction = (2 * rand * (locPos - currPos)) + (2 * rand * (globPos - currPos));

	velVal = currVel + direction;
	return velVal;
}


double agent::velThree(double currVel, double currPos, double locPos, double globPos, double cOne, double cTwo, double w) {
	double velVal;
	double rand = randDoubOne();
	double direction = (cOne * rand * (locPos - currPos)) + (cTwo * rand * (globPos - currPos));

	velVal = (w * currVel) + direction;
	return velVal;
}



#endif

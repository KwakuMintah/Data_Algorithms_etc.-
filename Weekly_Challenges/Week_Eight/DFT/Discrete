#include <iostream>
#include "Complex.hpp"
using namespace std;
#ifndef DISCRETEHEADERDEF
#define DISCRETEHEADERDEF

double pi = 3.14159265359;
const int iter = 500;


void genFunc(int size, double func[], double a, double b, double c) {
    int i;
    for (i = 0; i < size; i++) {
        func[i] = (a * i) + (b * i) + (c * i);
    }
}

void initArray(int size, double arr[]) {
    int i;
    double t;
    double interval;
    t = 0.1;
    for (i = 0; i < size; i++) {
        interval = i * t;
        arr[i] = interval;
    }
}

void initArrayTwo(int size, int N, double arr[]) {
    int i = 0;
    double t;

    for (i = 0; i < size; i++) {
        t = double(i);
        double coefOne = (N + 0.5) * t;
        double coefTwo = t * 0.5;
        double num = sin(coefOne);
        double den = sin(coefTwo);
        double frac = num / den;
        arr[i] = frac - 1.0;
    }
}

void printArray(int size, double sample[], complexDouble fourier[]) {
    int i;
    for (i = 0; i < size; i++) {
        cout << "\n" << i << "    " << sample[i] << "    " << fourier[i].real << "    " << fourier[i].imag;
    }
}

void discreteFourier(int size, double sample[], complexDouble fourier[]) {
    int i = 0, j = 0;
    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            double num = 2 * pi;
            double frac = num / size;
            double kn = i * j;
            double coef = -1 * frac * kn;
            double cosin = cos(coef);
            double sine = sin(coef);
            complexDouble theEx;
            theEx.real = cosin;
            theEx.imag = sine;
            fourier[i].real += sample[i] * theEx.real;
            fourier[i].imag += sample[i] * theEx.imag;
        }
    }
}



int bitReversal(int size) {
    int i, check = size/2;
    int midpoint = size / 2;
    for (i = 0; i < size; i++) {
        if (i >= midpoint) {
            swap(i, midpoint);
        }
        while (check == size / 2) {
            if (check > midpoint) {
                return 0;
            }
            midpoint -= check;
            check /= 2;
        }
        midpoint += check;
        return midpoint;
    }
}

//The code runs but only prints zeros
void fastFourier(int size, complexDouble xArr[]) {
    int i, j, k, i_aug;
    double cosine, sine, log_two, pow_two, pow_div;
    complexDouble trace;
    log_two = int_log(size, 2);
    double zer = 0.0;
    double one = 1.0;
    j = bitReversal(size);
    for (i = 1; i < log_two + 1; i++) {
        pow_two = pow(2, i);
        pow_div = pow_two / 2;
        cosine = cos(pi / pow_div);
        sine = -1 * sin(pi / pow_div);
        for (j = 1; j < pow_div + 1; j++) {
            for (k = j - 1; k < size - 1; k++) {
                i_aug = i + pow_div;
                trace.real = xArr[i_aug].real * one - xArr[i_aug].imag * zer;
                trace.imag = xArr[i_aug].real * zer + xArr[i_aug].imag * one;
                xArr[i_aug].real = xArr[i].real - trace.real;
                xArr[i_aug].imag = xArr[i].imag - trace.imag;
                xArr[i].real += trace.real;
                xArr[i].imag += trace.imag;
            }
            trace.real = one;
            one = trace.real * cosine - zer * sine;
            zer = trace.real * sine + zer * cosine;
        }
    }
}

void fourierFunc(int size, double sample[], complexDouble output[]) {
    genFunc(size, sample, 1, 2, 3);
    discreteFourier(size, sample, output);
    printArray(size, sample, output);
}

void fastFourierFunc(int size, double sample[], complexDouble output[]) {
    genFunc(size, sample, 1, 2, 3);
    fastFourier(size, output);
    printArray(size, sample, output);
}

#endif
